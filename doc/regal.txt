Regal
=====
Jan Schnasse <schnasse@gmx.de>
:Author Initials: JS
:toc:
:icons:
:numbered:
:website: https://hbz-nrw.de

.Über dieses Dokument
**************************************
Falls Du nur an einer schnellen Installationsanleitung interessiert bist, [schaue hier]. Im nachfolgenden wird das Gesamtsystem ausführlich erläutert.

**************************************

Einleitung
----------
Regal ist eine ContentRepository zur Verwaltung und Veröffentlichung elektronischer Publikationen. Es wird seit 2013 am [Hochschulbibliothekszentrum (hbz)] entwickelt. 

Regal basiert auf den folgenden Kerntechnologien:

- Fedora Commons 3
- Elasticsearch 1.1
- Drupal 7
- Playframework 2.4
- MySQL 5
- Java 8
- PHP 5 

Für die Webarchivierung kommen außerdem Openwayback, Heritrix und WPull zum Einsatz. 

- openwayback hbz-2.3.2
- heritrix 3.2.0
- wpull

Regal ist ein mehrkomponentiges System. Einzelne Komponenten sind als Webservices realisiert und kommunizieren über HTTP-APIs miteinander. Derzeit sind folgende Komponenten im Einsatz

- https://github.com/edoweb/regal-api[regal-api]
- https://github.com/hbz/etikett[etikett]
- https://github.com/hbz/zettel[zettel]
- https://github.com/hbz/skos-lookup[skos-lookup]
- https://github.com/hbz/thumby[thumby]
- https://github.com/hbz/DeepZoomService/[deepzoomer]
- https://github.com/edoweb/regal-drupal[regal-drupal]

Themes

- https://github.com/edoweb/zbmed-drupal-theme[zbmed-drupal-theme]
- https://github.com/edoweb/edoweb-drupal-theme[edoweb-drupal-theme]



Über die Systemschnittstellen können eine ganze Reihe von Drittsystemen angesprochen werden. Die folgende Abbildung verschafft einen groben Überblick über eine typische Regal-Installation und die angebundenen Drittsysteme.

.Typische Regal-Installation mit Drupal Frontend, Backendkomponenten und angebundenen Drittsytemen
image::./resources/images/regal-arch-4.jpeg[Regal Überblick]

Konzepte
--------

Objektmodell
~~~~~~~~~~~~
Regal realisiert ein einheitliches Objektmodell in dem sich eine Vielzahl von Publikationstypen speichern lassen. Die Speicherschicht wird über [Fedora Commons 3] realisiert.

Eine einzelne Publikation besteht i.d.R. aus mehreren [Fedora Commons 3]-Objekten, die in einer hierarchischen Beziehung zueinander stehen. 

.Fedora Object
[options="header"]
|=================================================
|Name|Pflicht|Beschreibung
|DC | Ja | Von Fedora vorgeschrieben. Wird für die Fedora-interne Suche verwendet
|RELS-EXT | Ja | Von Fedora vorgeschrieben. Wird für viele Sachen verwendet - (1) Hierarchien - (2) Steuerung  der Sichtbarkeiten - (2) OAI-Providing
|data | Nein | Die eigentlichen Daten der Publikation. Oft ein PDF.
|metadata oder metadata2 | Nein | Bibliografische Metadaten. Metadata2 enthält Daten in anlehnung an Lobid 2.
|objectTimestamp | Nein | Eine Datei mit einem Zeitstempel. Der Zeitstempel wird bei bestimmten Aktionen gesetzt.
|seq | Nein | Eine Hilfsdatei mit einem JSON-Array. Das Array zeigt an, in welcher Reihenfolge Kindobjekte anzuzeigen sind. Dieses Hilfskonstrukt existiert, da in der RELS-EXT keine RDF-Listen abgelegt werden können.
|=================================================

Die Metadaten werden als ASCII-Kodierte N-Triple abgelegt. Da alle Fedora-Daten als Dateien im Dateisystem abgelegt werden, ist diese Veriante besonders robust gegen Speicherfehler. N-Triple ist ein Format, dass sich Zeilenweise lesen lässt. ASCII ist die einfachste Form der Textkodierung.

Namespaces und Identifier
~~~~~~~~~~~~~~~~~~~~~~~~~

Jede Regal-Installation arbeitet auf einem festgelegten Namespace. Wenn über die [regal-api] Objekte angelegt werden, finden sich diese immer in dem entsprechenden Namespace wieder. Hinter dem Namespace findet sich, abgetrennt mit einem Dopplepunkt eine hochlaufende Zahl, die i.d.R. über [Fedora Commons 3] bezogen wird.

Der so zusammengesetzte Identifier kommt in allen Systemkomponenten zum Einsatz.

.Beispiel Regal Identifier
[options="header"]
|=========================================================
|ID|Komponente|URL
|regal:1|drupal | http://localhost/resource/regal:1
|regal:1|regal-api|http://api.localhost/resource/regal:1
|regal:1|fedora | http://localhost:8080/fedora/objects/regal:1
|regal:1|elasticsearch | http://localhost:9200/regal/_all/regal:1
|=========================================================

Deskriptive Metadaten
~~~~~~~~~~~~~~~~~~~~~

Regal unterstützt eine große Anzahl von Metadatenfeldern zur Beschreibung von bibliografischen Ressourcen. Jedes in Regal verspeicherte Objekt kann mit Hilfe von RDF-Metadaten beschrieben werden. Das System verspeichert grundsätzlich alle Metadaten, solange Sie im richtigen Format an die Schnittstelle gespielt werden.

Darüberhinaus können über bestimmte Angaben bestimmte weitergehende Funktionen angesteuert werden. Dies betrifft u.A.:

- Anzeige und Darstellung
- Metadatenkonvertierungen
- OAI-Providing
- Suche

Alle bekannten Metadateneinträge werden in der Komponente [Etikett] verwaltet. In [Etikett] kann konfiguriert werden, welche URIs aus den RDF-Daten in das JSON-LD-Format von [regal-api] überführt werden. Außerdem kann die Reihenfolge der Darstellung, und das Label zur Anzeige gesetzt werden. 


.Etikett-Eintrag für dc:title
[options="header"]
|====================================================================================================
|Label|Pictogram|Name (json)|URI|Type|Container|Comment
|Titel| keine Angabe  | title | http://purl.org/dc/terms/title | String | keine Angabe | keine Angabe
|====================================================================================================

.Etikett-Eintrag als Json
....
"title":{
	"@id"="http://purl.org/dc/terms/title",
	"label"="Titel"
}
....

Die etikett Datenbank wird beim Neustart jeder [regal-api]-Instanz eingelesen. Außerdem wird die HTTP-Schnittstelle von Etikett immer wieder angesprochen, um zur Anzeige geeignete Labels für URIs in das System zu holen. Das [regal-api]-Modul läuft dabei auch ohne den Etikett-Services, allerdings nur mit eingeschränkter Funktionalität; beispielsweise fallen Anzeigen von verlinkten Ressourcen (und das ist in Regal fast alles) weniger schön aus.

Wie kommen bibliografische Metadaten ins System?
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

In Regal können bibliografische Metadaten aus dem hbz-Verbundkatalog an Ressourcen "angelinkt" werden. Dies erfolgt über Angabe der ID des entsprechenden Titelsatzes (z.b. HT017766754). Mit Hilfe dieser ID kann Regal einen Titelimport durchführen. Dabei wird auf die Schnittstellen der [Lobid-API] zugegriffen. 

Regal bietet außerdem die Möglichkeit Metadaten über Erfassungsmasken zu erzeugen und zu speichern. Dies erfolgt mit Hilfe des Moduls [Tettel]. [Zettel] ist ein Webservices, der verschiedene HTML-Formulare bereitstellt. Die Formulare können RDF-Metadaten einlesen und ausgeben. Zettel-Formulare werden über Javascript in ein IFrame der eigentlichen Anwendung angebunden. Über Zettel werden Konzepte aus dem Bereich Linked Data umgesetzt. So können Feldinhalte über entsprechende Eingabeelemente in Drittsystemen recherchiert und verlinkt werden. Die Darstellung von Links erfolgt in Zettel mit Hilfe von [Etikett]. Umfangreichere Notationssysteme wie Agrovoc oder DDC werden über einen eigenen Index aus dem Modul [skos-lookup] eingebunden. Zettel unterstützt zur Zeit folgende Linked-Data-Quellen:

- Lobid (GND)
- Lobid (Ressource)
- Agrovoc
- DDC
- CrossRef (Funder Registry)
- Orcid

Anzeige und Darstellung
~~~~~~~~~~~~~~~~~~~~~~~

Über die Schnittstellen der [regal-api] können unterschiedliche Darstellungen einer Publikation bezogen werden. Über [Content Negotiation] können Darstellungen per HTTP-Header angefragt werden. Um unterschiedliche Darstellungen im Browser anzeigen zu lassen, kann außerden, über das Setzen von entsprechenden Endungen, auf unterschiedliche Representationen eine Resource zugegriffen werden.

.Auswahl von Pfaden zu unterschiedlichen Representationen einer Ressource
....
/resource/danrw:1
/resource/danrw:1.json
/resource/danrw:1.rdf
/resource/danrw:1.epicur
/resource/danrw:1.mets
....

In der HTML-Darstellung greift [regal-api] auf den Hilfdienst [thumby] zu, um darüber Thumbnail-Darstellungen von PDFs oder Bilder zu kreieren. Bei großen Bildern wird außerdem der [DeepzoomerService] angelinkt, der eine Darstellung von Hochauflösenden Bildern über das Tool Openseedragon erlaubt. Video- und Audio-Dateien werden über die entsprechenden HTML5 Elemente gerendert.

Metadatenkonvertierung
~~~~~~~~~~~~~~~~~~~~~~

Für die Metadatenkonvertierung gibt es kein festes Vorgehensmodell oder Werkzeug. I.d.R. gibt es für jede Representation eine oder eine Reihe von Javaklassen, die für eine On-the-fly-Konvertierung sorgen. Die HTML-Darstellung basiert grundlegend auf denselben Daten, die auch im [Elasticsearch]-Index liegen und ist im wesentlichen eine JSON-LD-Darstellung, die mit Hilfe der in [etikett] hinterlegten Konfiguration aus den bibliografischen Metadaten gewonnen wurde.

OAI-Providing
~~~~~~~~~~~~~

Öffentlich zugängliche Publikationen sind auch über die OAI-Schnittstelle verfügbar. Dabei wird jede Publikation einer Reihe von OAI-Sets zugeordnet und in unterschiedlichen Formaten angeboten.

.OAI Set
[options="header"]
|=========================================
|Set|Kriterium
|ddc:* | Wenn ein dc:subject mit dem String "http://dewey.info/class/" beginnt, wird ein Set mit der entsprechenden DDC-Nummer gebildet und die Publikation wird zugeordnet
|contentType | Der "contentType" weist darauf hin, in welcher Weise die Publikation in Regal. Abgelegt ist.
|open_access | All Publikationen, die als Sichtbarkeit "public" haben
|urn-set-1 | Publikationen mit einer URN, die mit urn:nbn:de:hbz:929:01 beginnt
|urn-set-2 | Publikationen mit einer URN, die mit urn:nbn:de:hbz:929:02 beginnt
|epicur | Publikationen, die in einem URN-Set sind
|aleph | Publikationen , die mit einer Aleph-Id verknüpft sind
|edoweb01 |  spezielles, pro [regal-api]-Instanz konfigurierbares Set für alle Publikationen, die im aleph-Set sind
|ellinet01 |  spezielles, pro [regal-api]-Instanz konfigurierbares Set für alle Publikationen, die im aleph-Set sind


.OAI Metadatenformat (metadataprefix)[options="header"]
|=========================================
|Format|Kriterium
|oai_dc| Alle öffentlich sichtbaren Objekte, die als bestimmte ContentTypes angelegt wurden.
|epicur| Alle Objekte, die eine URN haben
|aleph| Alle Objekte, die einen persistenten Identifier haben
|mets| Wie oai_dc
|rdf| Wie oai_dc
|wgl| Alle Objekte die über das Feld "collectionOne" einer Institution zugeordnet wurden und über den ContentType "article" eingeliefert urden.

Suche
~~~~~

Der Elasticsearch-Index wird mit Hilfe einer JSON-LD Konvertierung befüllt. Die Konvertierung basiert im wesentlichen auf den bibliografischen Metadaten der einzelnen Ressourcen und wir mit Hilfe der in [etikett] hinterlegten Konfiguration erzeugt.

Zugriffsberechtigungen und Sichtbarkeiten
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Regal setzt ein rollenbasiertes Konzept zur Steuerung von Zugriffsberechtigungen um. Eine besondere Bedeutung kommt dem lesenden Zugriff auf Ressourcen zu. Einzelne Ressourcen können in ihrer Sichtbarkeit so eingeschränkt werden, dass nur mit den Rechten einer bestimmten Rolle lesend zugegriffen werden kann. Dabei kann der Zugriff auf Metadaten und Daten separat gesteuert werden. 

.Screenshot zur Verdeutlichung von Sichtbarkeiten in Regal
image::./resources/images/accessControl.png[Regal Zugriffsrechte]


Die Konfiguration hat Auswirkungen auf die Sichtbarkeit einer Publikation in den unterschiedlichen Systemteilen. Die folgende Tabelle veranschaulicht den derzeitigen Stand der Implementierung.

Sichtbarkeiten, Operationen, Rollen
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.Lesender Zugriff auf Metadaten
[options="header"]
|==============================================
|Sichtbarkeit|Rolle
|public | GUEST,READER,SUBSCRIBER,REMOTE,ADMIN,EDITOR
|private| ADMIN,EDITOR
|==============================================

.Lesender Zugriff auf Daten
[options="header"]
|==============================================
|Sichtbarkeit|Rolle
|public | GUEST,READER,SUBSCRIBER,REMOTE,ADMIN,EDITOR
|restricted| READER,SUBSCRIBER,REMOTE,ADMIN,EDITOR
|remote|READER,SUBSCRIBER,REMOTE,ADMIN,EDITOR
|single|SUBSCRIBER,ADMIN,EDITOR
|private| ADMIN,EDITOR
|==============================================

Benutzerverwaltung
~~~~~~~~~~~~~~~~~~
Die Benutzerverwaltung von Regal findet innerhalb von Drupal statt. Zwar können auch in der [regal-api] Benutzer angelegt werden, jedoch ist die Implementierung in diesem Bereich erst rudimentär.

Drupal
^^^^^^
Benutzer in Drupal können über das Modul [regal-drupal] unterschiedliche Rollen zugewiesen werden. Die Authorisierung erfolgt passwortbasiert. Alle Drupal-Benutzer greifen über einen vokonfigurierten Accessor auf die [regal-api] zu. Alle Zugriffe erfolgen verschlüsselt unter Angabe eines Passwortes. Die Rolle mit deren Berechtigungen zugegriffen wird, wird dabei in [regal-drupal] gesetzt. Die Drupal-BenutzerId wird als Metadatum in Form eines proprietären HTTP-Headers mit an [regal-api] geliefert.

Regal-Api
^^^^^^^^^
Auch in regal-api können Api-Benutzer angelegt werden. Zur Benutzerverwaltung wird eine MySQL-Datenbank eingesetzt, in der die Passworte der Nutzer abgelegt sind (Hash+Salt).

Ansichten
=========

Um Daten, die in [regal-api] abgelegt wurden zur Anzeige zu bringen sind i.d.R. mehrere Schritte nötig. Die genau Vorgehensweise ist davon abhängig, wo die Daten abgelegt werden. Grundsätzlich basiert die HTML-Darstellung auf den Daten, die unter dem Format `.json2` einer Ressource abrufbar sind und einen Eintrag in context.json haben. 

1. Eintrag des zugehörigen RDF-Properties in die entsprechende [etikett]-Instanz, bzw. in die `/conf/labels.json`. Der Eintrag muss einen Namen, ein Label und einen Datentyp haben. [regal-api] neu starten, bzw mit `POST /context.json` das neu Laden der Contexteinträge erzwingen.
2. Dies müsste reichen, um eine Standardanzeige in der HTML-Ausgabe zu erreichen
3- Wenn die Daten nicht erscheinen, sollte man überprüfen, ob sie unter dem Format `.json2` erscheinen. Wenn nicht, stellt sich die Frage, wo die Daten abgelegt werden. Komplett werden nur die Daten aus dem Fedora Datenstrom /metadata2 prozessiert. Befindet sich das Datum in z.B. im /RELS-EXT Datenstrom so muss es zunächst manuell unter `helper.JsonMapper#getLd2()` in das JSON-Objekt eingefügt werden.
4. Einige Felder werden auch ausgeblendet. Dies geschieht in [regal-api] unter `/public/stylesheets/main.css` und in Drupal innerhalb der entsprechenden themes.
5. Um spezielle Anzeigen zu realisieren muss schließlich im HTML-Template angefasst werden, unter `/app/views/tags/resourceView.scala.html` .

Insgesamt läuft es also so: Alles was in [etikett] konfiguriert ist, wird auch ins JSON und damit ins HTML übernommen. Dinge, die im HTML nicht benötigt werden, werden über CSS wieder ausgeblendet.

Software
--------

Nachfolgend erfolgt eine Innenansicht der einzelnen Module. Die Integration der Module erfolgt i.d.R. über HTTP. Die Module werden über entsprechende Einträge in der Apache-Konfiguration sichtbar gemacht. Es handelt sich also um eine Webservice-Architektur, in der alle Webservices über einen Apache-Webserver und entsprechende Einträge in ihren Konfigurationsdateien miteinander verbunden werden.

.Regal Abhängigkeiten
image::./resources/images/regal-dependencies.jpeg[Regal Abhängigkeiten]


regal-api 
~~~~~~~~~~
Repo: <https://github.com/edoweb/regal-api>

Mit regal-api werden alle grundlegenden Funktionen von Regal bereitgestellt. Dies umfasst:

- HTTP Schnittstelle
- Sichtbarkeiten, Zugriffskontrolle, Rollen
- Speicherung, Datenhaltung
- Konvertierungen
- Ansichten
- Suche
- Webarchivierung

Der Webservice ist auf Basis von [Play 2.4.2] realisiert und bietet eine reichhaltig HTTP-API zur Verwaltung von elektronischen Publikationen an. Die [regal-api] operiert auf [Fedora Commons 3], [MySQL] und [Elasticsearch]. Über die API werden auch Funktionalitäten von [etikett], [thumby], [zettel] und [Deepzoomer] angesprochen. Für die Webarchivierung werden [heritrix], [wpull] und [openwayback] angebunden.

Kofiguration
^^^^^^^^^^^^

.Dateien im /conf Verzeichnis
[options="header"]
|==================================================================
|Datei | Beschreibung
|**aggregations.conf**	| Diese Datei wird verwendet um die Schnittstelle `/browse` zu konfigurieren. Die Einträg im Object "aggs" können direkt über die `/browse` Schnittstelle angesprochen werden. Mit Hilfe des Elasticsearch-Indexes wird dann eine entsprechende Antwort generiert. Beispiel: `/browse/rdftype` liefert eine Liste mit allen Publikationstypen, die im Index vorhanden sind.
|**application.conf.tmpl**	| Eine template Datei für die Hauptkonfiguration von [regal-api]. Diese Datei sollte zur lokalen Verwendung einmal nach application.conf kopiert werden. In der Datei sind alle Passwörter auf 'admin' gesetzt.
|crawler-beans.cxml	| Die Datei wird verwendet, wenn im Webarchivierungsmodul eine neue Konfiguration für eine Webseite angelegt wird.
|ehcache.xml	| die Konfiguration der Ehcache Komponente
|fedora-users.xml	| deprecated - Zur Löschung vorgeschlagen
|hbz_edoweb_url.txt	| deprecated - Zur Löschung vorgeschlagen
|html.html	| deprecated - Zur Löschung vorgeschlagen
|install.properties	| deprecated - Zur Löschung vorgeschlagen
|labels-edoweb.de	| Labels für eine bestimmt Regal-Instanz
|labels-for-proceeding-and-researchData.json	| deprecated - Zur Löschung vorgeschlagen
|labels-lobid.json	| deprecated - Zur Löschung vorgeschlagen
|labels-publisso.de	| Labels für eine bestimmte Regal-Instanz
|**labels.json**	| Eine sinnvolle Startkonfiguration. Die Datei wurde mit [etikett] erzeugt. Beim Start von [regal-api] wird zunächst versucht eine ähnliche Konfiguration direkt von einer laufenden [etikett]-Instanz zu holen. Wenn dies nicht klappt, wird auf die labels.json zurückgegriffen.
|list.html	|deprecated - Zur Löschung vorgeschlagen
|logback.developer.xml	| ein logging Konfiguration. Ich kopiere die immer nach logback.developer.js.xml (in .gitignore) und trage sie  dann in die application.conf ein. Auf diese Weise kann ich an Loglevels herumkonfigurieren ohne das in diese Änderungen in die Versionsverwaltung spielen zu müssen.
|logback.xml	| Konfiguration des Loggers. Diese Datei ist in application.conf eingetragen.
|mabxml-string-template-on-record.xml	| Eine template-Datei zur Generierung von MAB-Ausgaben.
|mail.properties	| Konfiguration zur Versendung von Mails. Standardmäßig schickt die Applikation eine Mail, sobald sie im Production-Mode neu gestartet wurde. Auch der Umzugsservice im Webarchivierungsmodul verschickt Mails.
|nwbib-spatial.ttl	| deprecated - Zur Löschung vorgeschlagen
|nwbib.ttl	|deprecated - Zur Löschung vorgeschlagen
|**public-index-config.json**	| Konfiguration des Elasticsearch-Indexes. Da in dem Index vorallem Metadaten liegen, soll fast nicht tokenisiert werden.
|**routes**	| Hier sind alle HTTP-Pfade übersichtlich aufgeführt.
|scm-info.sh	| Diese Datei kann man unter Linux in die profile-Konfiguration seines Benutzers einbinden. Dann erhält man im Terminal farbige Angabgen zu Git-Branches,etc.
|start-regal.sh	| deprecated - Zur Löschung vorgeschlagen
|tomcat-users.xml	|deprecated - Zur Löschung vorgeschlagen
|unescothes.ttl	|deprecated - Zur Löschung vorgeschlagen
|wglcontributor.csv	|deprecated - Zur Löschung vorgeschlagen
|===================================================================

Die Applikation
^^^^^^^^^^^^^^^

.Das /app Verzeichnis
[options="header"]
|===================================================================
|Package | Beschreibung
|default package | Hier befindet sich die Datei Global, die in [Play 2.4] noch eine große Rolle spielt. In der Datei können zum Beispiel Aktionen vor dem Start der Applikation erfolgen, auch können hier HTTP-Requests mit geloggt werden. Bestimmte Aktionen werden nur im Production-Mode ausgeführt, d.h. nur wenn die Applikation mit `start` gestartet wurde oder über `dist` ein entsprechendes Binary erzeugt wurde.
|actions | Hier sind Funktionen versammelt, die meist unmittelbar aus den Controller-Klassen aufgerufen werden.
|archive.fedora| Ein Reihe von Dateien, über die Zugriffe auf [Fedora Commons 3] organisiert werden. Hier finden sich auch einige Hilfsklassen (`Utils`). Das FedoraInterface zeigt an, welche Aktionen auf der Fedora ausgeführt werden. Der Code in diesem Paket gehört mit zu dem ältesten Code im gesamten Regal-Projekt. 
|archive.search| Zugriff auf die Elasticsearch
|authenticate| Regal verwendet Basic-Auth zur Authentifizierung. Um die entsprechenden Aufrufe in den Controllern zu Schützen wird eine Annotation `@BasicAuth` verwendet. Diese findet sich hier. Die Annotation selbst bewirkt, dass jeder Controller-Aufruf durch die Methode asicAuth` der Klasse `BasicAuthAction.java` läuft. Ziel dieser Prozedur ist es, dem Zugriff die Berechtigungen einer bestimmten Rolle zuzuordnen.
|controllers| Der Code, der in diesen Klassen organisiert ist, wird bei den entsprechenden HTTP-Aufrufen ausgeführt. In der `/conf/routes` Datei kann man sehen, welcher HTTP-Aufruf, welchen Methoden-Aufruf zur Folge hat. Die Controller-Klassen sind i.d.R. von der Klasse MyController  abgeleitet, die Hilfsfunktionen bereitstellt, aber auch Funktionen zur Überprüfung von Zugriffsrechten. Die Überprüfung von Zugriffsrechten erfolgt durch eingebettet Calls und wird über die internen Klassen von MyController realisiert. Beispiel:
Die Funktion `listNodes` in der Klasse `controllers.Resource` ruft ihre Prozeduren eingebettet in eine Funktion der Klasse `ListAction` auf. Die Klasse `ListAction` ist in `MyController` implementiert und überprüft, ob der Aufruf mit der nötigen Berechtigung erfolgte.
|converter.mab| Die Klasse realisiert noch das OAI-Providing von MAB-Daten. Ursprünglich war hier geplant, dass wesentlich umfangreichere MAB-Datensätze geliefert werden würden. Daher wird hier mit einer eigenen Template-Engine gearbeitet, etc. Ich erinnere mich gerne an diese Arbeiten, auch wenn sie größtenteils nie genutzt und zu Ende geführt wurden. Ein lustiges Produkt in diesem Kontext ist auch die Klasse `models.MabRecord`.
|de.hbz.lobid.helper| Der hier befindliche Code kommt ursprünglich aus einem anderen Paket, wurde dann aber beim Neuaufbau des Lobid 2 Datendienstes gemeinsam mit den Kollegen weiterentwickelt und ist schließlich wieder hier gelandet. Mittlerweile ist die offizielle JSON-LD-Library soweit entwickelt, dass man die Konvertierung auch darüber machen kann. Achja, denn dafür ist der Code: Lobid N-Triples in schönes JSON umzuformen, das dann auch in den Elasticsearch-Index kann.
|helper| Die mit Abstand wichtigste Klasse in diesem Package heißt `JsonMapper`. Hier wird das JSON für Index und Ansichten erzeugt.
|helper.mail| Emails verschicken.
|helper.oai| Einige Klassen zur Regelung des OAI-Providings. Der `OAIDispatcher` analysiert, ob und wie ein `Node` an die OAI-Schnittstelle gelangt. 
|models|Die wichtigste Klasse hier ist `Node` über diese Klasse läuft der Großteil des Datentransportes. 
|views| Templates in der Sprache `Twirl` und einige Java-Hilfsklassen.
|views.mediaViewers| Ein paar Viewer, die über die Hilfsklasse `ViewerInfo` in `tags.resourceView` eingebunden werden können.
|views.oai| Mit `Twirl` XML zu generieren war keine gute Idee.
|views.tags| Hilfstemplates.
|===================================================================

Gedanken des Authors
^^^^^^^^^^^^^^^^^^^^
Der in [regal-api] versammelte Code ist ein historisch gewachsenes Sammelsurium. Zu irgendeinem Zeitpunkt habe ich angefangen neue Funktionalitäten vorzugsweise nicht mehr hier zu integrieren. Auf diese Weise sind [etikett], [thumby], [zettel] und [skos-lookup] entstanden. 

Schaut man sich die sieben groben Aufgabenbereiche an, die von [regal-api] abgedeckt werden, so könnten weitere Unterteilungen in zusätzliche Webservices sinnvoll sein. Gerade der Bereich Webarchivierung mit seiner hohen Komplexität erscheint mir für eine Auskopplung prädestiniert. Tools wie [heritrix],[wpull] und [openwayback] könnten so aus der Gesamtkomplexität entfernt werden.  



etikett
~~~~~~~
Repo: <https://github.com/hbz/etikett>

Etikett ist eine einfache Datenbankanwendung, die es erlaubt menschenlesbare Labels für URIs abzulegen. Über eine HTTP-Schnittstelle kann dann nach dem Label gefragt werden.
In Etikett sind verschiedene Lookups realisiert, die dynamisch Labels für URIs finden können. Beispiele:

- Crossref
- Geonames
- GND
- Openstreetmap
- Orcid
- RDF, Skos, etc.

Fragt man etikett nach einem Label, so antwortet Etikett mit dem Ergebnis des Lookups. Wenn Etikett nicht in der Lage ist, ein Label zu finden, wird die URI, mit angefragt wurde, zurückgegeben.

Etikett kann auch als Cache verwendet werden. So werden authentifizierte Anfragen in einer Datenbank persistiert. Erneute Anfragen werden dann aus der Datenbank beantwortet, ein erneuter Lookup wird eingespart. Einmal persistierte Labels werden nicht invalidiert. Die Invalidierung kann von außerhalb über authentifizierte HTTP-Zugriffe realisiert werden, stellt aber insgesamt noch ein Desiderat dar.

Etikett kann auch mit Labels vorkonfiguriert werden. Dabei können zusätzliche Informationen zu jeder URIs mit abgelegt werden. Folgende Informationen können in etikett abgelegt werden:

- URI
- Label
- Weight - Zur Definition von Anzeigereihenfolgen.
- Pictogram Iconfont-ID - Kann anstatt oder zusätzlich zum Label angezeigt werden.
- ReferenceType - JSON-LD Typ
- Container - JSON-LD Container
- Beschreibung - Kommentar als Markdown

Mit Hilfe dieser Angaben kann Etikett auch einen "JSON-LD Context" bereitstellen. Insgesamt wird über Etikett eine Art "Application Profile" realisiert. Das Profil gibt Auskunft, welche Metadatenfelder (definiert als URIs) in welcher Weise (Typ, Container) Verwendung finden und wie sie angezeigt werden sollen (Label, Weight, Pictogram).

Im Regal-Kontext wird [etikett] an vielen Stellen verwendet. 

- Zur Wandlung von RDF nach JSON-LD
- Zur Anreicherung von RDF Importen
- Zur menschenlesbaren Darstellung von RDF
- Zur Konfiguration von Labels, Anzeigereihenfolgen und Pictogrammen
- Als Cache

Konfiguration
^^^^^^^^^^^^^

.Dateien im /conf Verzeichnis
[options="header"]
|==================================================================
|Datei | Beschreibung
|**evolutions** | Dieses Verzeichnis enthält SQL-Skripte, die bei Änderungen des Datenbankschemas automatisch über EBean angelegt werden. Beim nächsten Deployment einer neuen Etikett-Version werden die Skripte automatische angewendet. Die Skripte enthalten immer einen mit "Up" markierten Part, und einen mit "Down" markierten Part (für rollbacks).
|**application.conf**| Hier kann ein Benutzer eingestellt werden. Alle Klassen im Verzeichnis `models.*` erhalten eine SQL-Tabelle. 
| ddc.turtle | Eine DDC Datei. Die Datei bietet Labels für DDC-URIs an.
| labels.json | Eine Labels-Datei, die zur initialen Befüllung verwendet werden kann.
| regal.turtle | Eine Labels-Datei, die zur initialen Befüllung verwendet werden kann.
| **routes** | Alle HTTP-Schnittstellen übersichtlich in einer Datei
| rpb.turtle | Eine Labels-Datei, die zur initialen Befüllung verwendet werden kann.
|rpb2.turtle |Eine Labels-Datei, die zur initialen Befüllung verwendet werden kann.
|===================================================================

Die Applikation
^^^^^^^^^^^^^^^

.Das /app Verzeichnis
[options="header"]
|===================================================================
|Package | Beschreibung
|default | In `Global` werden die Requests mit geloggt.
|controllers| In `Application` werden alle HTTP-Operationen implementiert. Unterstützt wird BasicAuth.
|helper| Verschiedene Klassen, die eine URI verfolgen und versuchen ein Label aus den zurückgelieferten Daten zu kreieren.
|models| Das Model `Etikett` ist persistierbar.
|views| Die meisten HTTP-Operationen lassen sich auch über eine Weboberfläche im Browser aufrufen.
|===================================================================

 
zettel
~~~~~~
Repo: <https://github.com/hbz/zettel>

Zettel ist ein Webservice zur Bereitstellung von Webformularen. Die Webformulare können über ein HTTP-GET geladen werden. Sollen existierende Daten in ein Formular geladen werden, so können diese Daten als Form-encoded, als JSON, oder als RDF-XML über ein HTTP-POST in das Formular geladen werden. Gleichzeitig kann spezifiziert werden, in welchem Format das Formular Daten zurückliefern soll.

Zettel verfügt über keine eigene Speicherschicht. Daten die über ein Formular erzeugt wurden, werden in der HTTP-Response zurückgeliefert. Zur Integration von Zettel in andere Applikationen wurde ein Kommunikationspattern entwickelt, das auf Javascript beruht. Das Zettel-Formular wird hierzu in einem IFrame in die Applikation eingebunden. Die Applikation muss außerdem ein Javascript einbinden, das auf bestimmte Nachrichten aus dem IFrame lauscht. Bei bestimmte Aktionen sendet das Zettel-Formular dann Nachrichten an die Applikation und erlaubt dieser darauf zu reagieren. Um Daten von Zettel in die Applikation zu bekommen, werden diese im HTML-DOM gespeichert und können von dort durch die Applikation entgegengenommen werden.

.Zettel Datenfluss
image::./resources/images/zettel-flos.png[Zettel Datenfluss]
:figure-caption: Logo

Konfiguration
^^^^^^^^^^^^^

.Dateien im /conf Verzeichnis
[options="header"]
|==================================================================
|Datei | Beschreibung
|**application.conf**| Die Datei enthält einen Eintrag zur Konfiguration von [etikett]. Über einen weiteren Eintrag können "Hilfetexte" angelinkt werden. Die Hilfetexte müssen in einer statischen HTML abgelegt sein. Am Ende der Datei werden einige Limits deutlich über den Standard erhöht, damit die großen RDF-Posts auch funktionieren.
|**collectionOne.csv**| Die Datei regelt den Inhalt eines Combo-Box widgets mit id collectionOne.
|**ddc.csv**|Die Datei regelt den Inhalt eines Combo-Box widgets mit id ddc.
|labels.json|Ein paar labels, falls keine Instanz von [etikett] erreichbar ist.
|logback.xml| Logger Konfiguration.
|**professionalGroup.csv**|Die Datei regelt den Inhalt eines Combo-Box widgets mit id professionalGroup.
|routes| Alle HTTP-Pfade übersichtlich in einer Datei
|==================================================================

Die Applikation
^^^^^^^^^^^^^^^

.Das /app Verzeichnis
[options="header"]
|===================================================================
|Package | Beschreibung
|controllers | Es gibt nur einen Controller. Hier ist sowohl die Basisfunktionalität implementiert, als auch die Autocompletion-Endpunkte für die unterschiedlichen Widgets. Die Schnittstelle zu Abhandlung von Formulardaten ist recht generisch gehalten. Über eine ID wird das entsprechende Formular aus dem services.ZettelRegister geholt und das zugehörige Formular wird gerendert. Die Formular erhalten dabei unterschiedliche Templates (z.B. `views.Article`) und unterschiedliche Modelklassen (z.B. models.Article).
|models | Das Model "Article" heißt aus historischen Gründen so. Tatsächlich können mittlerweile auch Kongressschriften und Buchkapitel darüber abgebildet werden (vermutlich wird sich der Name nochmal ändern). Das Model "Catalog" dient zum Import von Daten aus dem Aleph-Katalog (über Lobid). Mit ResearchData steht ein prototypisches Model zur Verarbeitung von Daten über Forschungsdaten zur Verfügung. Alle Models basieren auf einem einzigen "fetten" ZettelModel. Das ZettelModel enthält auch Funktionen zur De/Serialisierung in RDF und Json.
|services| Hier werden verschiedene Hilfsklassen versammelt. Die Klasse ZettelFields enthält ein Mapping zur RDF-Deserialisierung. 
|views| Alle HTML-Sichten und die eigentlichen Formulare.
|===================================================================

skos-lookup
~~~~~~~~~~~

Repo: <https://github.com/hbz/skos-lookup>

Slides: <http://hbz.github.io/slides/siit-170511/#/>

[skos-lookup] dient zur Unterstützung von [zettel]. Der Webservice startet eine eingebettete Elasticsearch-Instanz und verfügt über eine Schnittstelle um SKOS-Daten in separate Indexe zu importieren und Schnittstellen zur Unterstützung von jQuery-Autocomplete- und Select2-Widgets aufzubauen. Auf diese Weise können auch umfangreichere Thesauri und Notationssysteme in den Formularen von [zettel] fachgerecht angelinkt werden. [skos-lookup] unterstützt auch mehrsprachige Thesauri.

Konfiguration
^^^^^^^^^^^^^

.Dateien im /conf Verzeichnis
[options="header"]
|==================================================================
|Datei | Beschreibung
|**application.conf** | Hier wird der interne Elasticsearch-Index konfiguriert. Auch werden einige Speichereinstellungen erhöht. Damit auch große SKOS-Dateien geladen werden können, sollten auch die Java-Opts erhöht werden.
|logback.xml| Logger Konfiguration
|routes| Alle HTTP-Pfade übersichtlich in einer Datei
|skos-context.json | Ein JSON-LD-Kontext zur Umwandlung von RDF nach JSON. (Origianl von: Jakob Voss)
|skos-setting.json | Settings zur Konfiguration des Elasticsearchindexse. (Original von: Jörg Prante)
|==================================================================

Die Applikation
^^^^^^^^^^^^^^^

.Das /app Verzeichnis
[options="header"]
|===================================================================
|Package | Beschreibung
|controllers | Alles in einem Controller. Die API-Methoden liefern HTML und JSON, so dass man sie aus dem Browser, aber auch über andere Tools ansprechen kann.
|elasticsearch| Eine embedded Elasticsearch. Dies hat den Vorteil, dass man eine aktuellere Version nutzen kann, als z.B. die [regal-api].
|services|Hilfsklassen zum Laden der Daten.
|views| Ein Formular um neue Daten in die Applikation zu laden. Und ein Beispielformular zur Demonstration der Nutzung.
|===================================================================


thumby
~~~~~~
Repo: <https://github.com/hbz/thumby>

[thumby] realisiert einen Thumbnail-Generator. Über ein HTTP-GET wird [thumby] die URL eines PDFs, oder eines Bildes übergeben. Sofern die [thumby] den Server kennt, wird es versuchen ein Thumbnail der zurückgelieferten Daten zu erstellen. Die Daten werden dauerhaft auf der Platte abgelegt und zukünftige Requests, die auf dasselbe Bild verweisen werden direkt aus dem Speicher von [thumby] beantwortet.

Konfiguration
^^^^^^^^^^^^^

.Dateien im /conf Verzeichnis
[options="header"]
|==================================================================
|Datei | Beschreibung
|**application.conf** | Hier wird eine Whitelist gesetzt. Thumby verarbeitet nur URLs von den hier angegebenen Quellen. Hier wird auch der Pfad auf der Platte gesetzt, unter dem Thumby thumbnail-Daten ablegt.
|routes| Alle HTTP-Pfade übersichtlich in einer Datei
|==================================================================

Die Applikation
^^^^^^^^^^^^^^^

.Das /app Verzeichnis
[options="header"]
|===================================================================
|Package | Beschreibung
|controllers | Der Controller realisiert eine GET-Methode, über die Thumbnails erzeugt und zurückgegeben werden.
|helper| Klassen zur Organisation des Speichers und zur Thumbnailgenerierung.
|views| Es gibt eine Oberfläche mit einem Upload-Formular.
|===================================================================


deepzoomer
~~~~~~~~~~
Repo:<https://github.com/hbz/DeepZoomService>

Der [DeepZoomService] kann als WAR in einem Application-Server deployed werden. Mit dem Deepzoomer können pyramidale Bilder erzeugt, gespeichert und über eine OpenSeadragon-konforme Schnittstelle abgerufen werden. Auf diese Weise kann in Regal eine Viewer-Komponente realisiert werden, die die Anzeige sehr großer, hochaufgelöster Bilder im Webbrowser unterstützt.

Konfiguration
^^^^^^^^^^^^^

.Dateien im /conf Verzeichnis
[options="header"]
|==================================================================
|Datei | Beschreibung
|**deepzoomer.cfgf** | Hier werden lokale Verzeichnisse, aber auch die Server-URLs, unter denen der Service öffentlich abrufbar ist, gesetzt.
|==================================================================


regal-drupal
~~~~~~~~~~~~
Repo: <https://github.com/edoweb/regal-drupal>

Ein Drupal 7 Modul über das Funktionalitäten der [regal-api] angesprochen werden können. Das Modul bietet Oberflächen zur Konfiguration, zur Suche und zur Verwaltung von Objekthierarchien.


Die Applikation
^^^^^^^^^^^^^^^

.Verzeichnisstruktur
[options="header"]
|===================================================================
|Verzeichnis |Beschreibung
|edoweb| Hier ist der Code für die Oberflächen. 
|edoweb-field|Hier werden Felder für unterschiedliche RDF-Properties in der Drupal-Datenbank konfiguriert. Der Code ist größtenteils obsolet, da die Feldlogik nicht mehr benutzt wird.
|edoweb_storage| Hier sind die Zugriffe auf [regal-api] und [elasticsearch] zu finden.
|===================================================================

edoweb-drupal-theme
~~~~~~~~~~~~~~~~~~~
Repo: <https://github.com/edoweb/edoweb-drupal-theme>

Eine Reihe von Stylsheets, CSS, Icons zur Gestaltung einer Oberfläche für den Server https://edoweb-rlp.de

zbmed-drupal-theme
~~~~~~~~~~~~~~~~~~
Repo: <https://github.com/edoweb/zbmed-drupal-theme>
Eine Reihe von Stylsheets, CSS, Icons zur Gestaltung einer Oberfläche für den Server https://repository.publisso.de

openwayback
~~~~~~~~~~~
Repo: https://github.com/iipc/openwayback
**Achtung**: Es gibt einen am hbz entwickelten Branch. Dieser ist nicht auf Github.

Openwayback ist eine Webapplikation die im ROOT Bereich eines Tomcats installiert werden will. Sie kann Verzeichnisse mit WARC-Dateien indexieren und darauf eine Oberfläche zur Recherche und zur Navigation aufbauen.

heritrix
~~~~~~~~~
Heritrix ist ein Werkzeug zur Sammlung von Webseiten. Heritrix startet standalone als Webapplikation und bietet eine Weboberfläche zur Verwaltung von Sammelvorgängen an. Eingesammelte Webseiten werden als WARC-Dateien in einem bestimmten Bereich der Platte abgelegt.


wpull
~~~~~
Wpull ist ein Kommandozeilen-Wermzeug zur Sammlung von Webseiten. Mit WPull können WARC-Dateien erzeugt werden.


Fedora Commons 3
~~~~~~~~~~~~~~
Fedora Commons 3 ist ein Repository-Framework. Für Regal wird vorallem die Speicherschicht von Fedora Commons 3 benutzt. Fedora-Commons legt alle Daten im Dateisystem (auch) ab. Mit den Daten aus dem Dateisystem lässt sich eine komplette Fedora-Commons 3 Instanz von grundauf neu aufbauen.


MySql
~~~~~
MySQL wir von Fedora, regal-api und etikett verwendet.


Elasticsearch 1.1
~~~~~~~~~~~~~

Elasticsearch ist eine Suchmaschine und wird von [regal-api] verwendet. Auch [regal-drupal] greift auf den Index zu. 

Drupal 7
~~~~~~

Über Drupal 7 

Installation
------------

Vagrant
~~~~~~~

Vagrantskripts....

Server
~~~~~~
Ein paar Worte zu Benutzern, Sichtbarkeiten, etc. Von Vagrant auf den Server.


Administration
--------------

Ports
~~~~~

.Ports und Komponenten (typische Belegung)
[options="header"]
|====================
| Port | Komponente
| 80 /443 | Apache 2 
|8080 | fedora tomcat
|9090 | openwayback tomcat
|9200 | elasticsearch
| 9000/9100| regal-api
| 9001/9101 | thumby
| 9002/9102 | etikett
| 9003/9103 | zettel
| 9004/9104 | skos-lookup
|======================


Tabelle

Apache2
~~~~~~~
Tabelle


Matomo
~~~~~~

Skripte


Monit
~~~~~

Code

Scripts und Cronjobs
~~~~~~~~~~~~~~~~~~~~

Crontab

:!figure-caption:


